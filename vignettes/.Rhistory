}
if(any(unlist(lapply(priors, function(p) is.null(names(p)))))){ # if no inner values were named
for(i in 1:length(priors)){names(priors[[i]])<-unique(df[[group]])}
}
} else{ # else is for prior of length 1 for each element, in which case they need to replicated per groups
# this should also handle non-grouped formulae
l<-length(unique(df[[group]]))
priors<-lapply(priors, rep, length.out=l)
nms<-unique(df[[group]])
if(USEGROUP){
for(i in 1:length(priors)){names(priors[[i]])<-nms}
}
}
}
}
if(!any(names(out)=="prior")){
priorStanStrings<-lapply(pars, function(par) paste0("lognormal(log(", priors[[par]],"), 0.25)") )
priorStanStrings<-unlist(priorStanStrings)
parNames<-rep(names(priors), each = length(priors[[1]]))
if(USEGROUP){
groupNames<-rep(names(priors[[1]]), length.out = length(priorStanStrings))
names(priorStanStrings)<-paste(parNames, groupNames, sep="_")
} else {
names(priorStanStrings)<-parNames
}
if(matched_sigma =="homo" & !USEGROUP){
prior<-brms::set_prior('student_t(3,0,5)', dpar="sigma", class="Intercept")+
brms::set_prior('gamma(2,0.1)', class="nu")
} else if(matched_sigma == "gompertz"){
prior<-brms::set_prior('gamma(2,0.1)', class="nu")
} else{
prior<-brms::set_prior('student_t(3,0,5)', dpar="sigma")+
brms::set_prior('gamma(2,0.1)', class="nu")
}
for(nm in names(priorStanStrings)){
dist = priorStanStrings[[nm]]
pr = strsplit(nm, "_")[[1]][1]
if(USEGROUP & groupedPriors){ # if there are groups and they have different priors
gr = paste0(group, strsplit(nm, "_")[[1]][2])
prior<-prior+brms::set_prior(dist, coef = gr, nlpar = pr) # currently cannot set lb for prior with coef
# there is a clunky workaround but it wouldn't work with expected data types
# https://github.com/paul-buerkner/brms/issues/86
} else{
prior<-prior+brms::set_prior(dist, nlpar = pr, lb = 0)
}
}
prior <-unique(prior)
out[["prior"]]<-prior
# priors is still a list with ln centers
}
}
names(out)
priors
any(methods::is(priors, "brmsprior"))
ss<-growthSS(model = "gam", form=y~time|id/group, sigma="none",
df=gomp_df, type = "brms")
ss<-growthSS(model = "gam", form=y~time|id/group, sigma="homo",
df=gomp_df, type = "brms")
expect_s3_class(ss$formula, "brmsformula")
ss<-growthSS(model = "gam", form=y~time|id/group, df=gomp_df, type = "mgcv")
ss$formula
ss<-growthSS(model = "gam", form=y~time|id/group, sigma="power",
df=gomp_df, type = "nlme")
expect_equal(as.character(ss$formula$model), as.character(y ~ time * group))
fit <- suppressWarnings(fitGrowth(ss))
expect_s3_class(fit, "lme")
class(fit)
ss<-suppressMessages(growthSS(model = "gam", form=y~time|id/group,
df=gomp_df, type = "nls"))
fit <- fitGrowth(ss)
nlsPlot(fit, form=ss$pcvrForm, df=ss$df)
fit
fit$fitted.values
lmGamPlot<-function(fit, form, df = NULL, groups = NULL){
#fit = fit_outer; form = ss$pcvrForm; groups = NULL; df = ss$df; timeRange = NULL
#* `get needed information from formula`
x <-as.character(form)[3]
y <-as.character(form)[2]
if(grepl("\\|", x) & grepl("\\/",x)){
x3<-trimws(strsplit(x, "[|]|[/]")[[1]])
x<-x3[1]
individual = x3[2]
group = x3[3]
} else if (grepl("\\|", x)){
x2<-trimws(strsplit(x, "[|]")[[1]])
x<-x2[1]
group = x2[2]
individual=NULL
}
#* `filter by groups if groups != NULL`
if(!is.null(groups)){
df <- df[df[[groups]] %in% groups, ]
}
#* `add predictions`
plotdf <- df
plotdf$pred <- fit$fitted.values
#* `when implemented SE can be added here, see ?predict.nls`
#*
#* `layer for individual lines if formula was complete`
if(!is.null(individual)){
individual_lines<-ggplot2::geom_line(data=df, ggplot2::aes(x=.data[[x]], y=.data[[y]],
group = interaction(.data[[individual]],
.data[[group]]) ),
linewidth=0.25, color="gray40")
} else{
individual_lines<-list()
}
#* `plot`
plot<-ggplot(plotdf, ggplot2::aes(group = interaction(.data[[group]])))+
facet_wrap(stats::as.formula(paste0("~",group)))+
individual_lines+
ggplot2::geom_line(ggplot2::aes(x=.data[[x]], y=.data[["pred"]]), color="#CC4678FF", linewidth=0.7)+ # using middle of plasma pal
labs(x=x, y = as.character(form)[2])+
pcv_theme()
return(plot)
}
lmGamPlot(fit, form=ss$pcvrForm, df=ss$df)
lmGamPlot(fit, form=ss$pcvrForm, df=ss$df)
plot(fit)
summary(fit)
class(fit)
?bs
ss<-suppressMessages(growthSS(model = "gam", form=y~time|id/group,
df=gomp_df, type = "nls"))
expect_equal(as.character(ss$formula), as.character(y ~ bs(time) * group) )
source("~/Desktop/stargate/fahlgren_lab/pcvrLoad.R", echo=TRUE)
ss<-suppressMessages(growthSS(model = "gam", form=y~time|id/group,
df=gomp_df, type = "nls"))
fit <- fitGrowth(ss)
fit
lmGamPlot<-function(fit, form, df = NULL, groups = NULL){
#fit = fit_outer; form = ss$pcvrForm; groups = NULL; df = ss$df; timeRange = NULL
#* `get needed information from formula`
x <-as.character(form)[3]
y <-as.character(form)[2]
if(grepl("\\|", x) & grepl("\\/",x)){
x3<-trimws(strsplit(x, "[|]|[/]")[[1]])
x<-x3[1]
individual = x3[2]
group = x3[3]
} else if (grepl("\\|", x)){
x2<-trimws(strsplit(x, "[|]")[[1]])
x<-x2[1]
group = x2[2]
individual=NULL
}
#* `filter by groups if groups != NULL`
if(!is.null(groups)){
df <- df[df[[groups]] %in% groups, ]
}
#* `add predictions`
plotdf <- df
plotdf$pred <- fit$fitted.values
#* `when implemented SE can be added here, see ?predict.nls`
#*
#* `layer for individual lines if formula was complete`
if(!is.null(individual)){
individual_lines<-ggplot2::geom_line(data=df, ggplot2::aes(x=.data[[x]], y=.data[[y]],
group = interaction(.data[[individual]],
.data[[group]]) ),
linewidth=0.25, color="gray40")
} else{
individual_lines<-list()
}
#* `plot`
plot<-ggplot(plotdf, ggplot2::aes(group = interaction(.data[[group]])))+
facet_wrap(stats::as.formula(paste0("~",group)))+
individual_lines+
ggplot2::geom_line(ggplot2::aes(x=.data[[x]], y=.data[["pred"]]), color="#CC4678FF", linewidth=0.7)+ # using middle of plasma pal
labs(x=x, y = as.character(form)[2])+
pcv_theme()
return(plot)
}
lmGamPlot(fit, form=ss$pcvrForm, df=ss$df)
nlsPlot(fit, form=ss$pcvrForm, df=ss$df)
ss<-suppressMessages(growthSS(model = "gam", form=y~time|id/group, df=gomp_df, type = "mgcv"))
expect_equal(as.character(ss$formula), as.character(y ~ s(time, by = group) ) )
fit <- suppressWarnings(fitGrowth(ss))
class(fit)
fit
gamPlot<-function(fit, form, df = NULL, groups = NULL){
#fit = fit_outer; form = ss$pcvrForm; groups = NULL; df = ss$df; timeRange = NULL
#* `get needed information from formula`
x <-as.character(form)[3]
y <-as.character(form)[2]
if(grepl("\\|", x) & grepl("\\/",x)){
x3<-trimws(strsplit(x, "[|]|[/]")[[1]])
x<-x3[1]
individual = x3[2]
group = x3[3]
} else if (grepl("\\|", x)){
x2<-trimws(strsplit(x, "[|]")[[1]])
x<-x2[1]
group = x2[2]
individual=NULL
}
#* `filter by groups if groups != NULL`
if(!is.null(groups)){
df <- df[df[[groups]] %in% groups, ]
}
#* `add predictions`
plotdf <- df
plotdf$pred <- fit$fitted.values
#* `when implemented SE can be added here, see ?predict.nls`
#*
#* `layer for individual lines if formula was complete`
if(!is.null(individual)){
individual_lines<-ggplot2::geom_line(data=df, ggplot2::aes(x=.data[[x]], y=.data[[y]],
group = interaction(.data[[individual]],
.data[[group]]) ),
linewidth=0.25, color="gray40")
} else{
individual_lines<-list()
}
#* `plot`
plot<-ggplot(plotdf, ggplot2::aes(group = interaction(.data[[group]])))+
facet_wrap(stats::as.formula(paste0("~",group)))+
individual_lines+
ggplot2::geom_line(ggplot2::aes(x=.data[[x]], y=.data[["pred"]]), color="#CC4678FF", linewidth=0.7)+ # using middle of plasma pal
labs(x=x, y = as.character(form)[2])+
pcv_theme()
return(plot)
}
gamPlot(fit, form=ss$pcvrForm, df=ss$df)
ss$formula
ss<-suppressMessages(growthSS(model = "gam", form=y~time|id/group, df=gomp_df, type = "mgcv"))
fit <- suppressWarnings(fitGrowth(ss))
gamPlot(fit, form=ss$pcvrForm, df=ss$df)
fit
ss$formula
ss$formula <- as.formula("y ~ 0+group+s(time, by = group)")
fit <- suppressWarnings(fitGrowth(ss))
gamPlot(fit, form=ss$pcvrForm, df=ss$df)
fit
nlsPlot(fit, form=ss$pcvrForm, df=ss$df)
ss<-growthSS(model = "gam", form=y~time|id/group, sigma="power",
df=gomp_df, type = "nlme")
expect_equal(as.character(ss$formula$model), as.character(y ~ time * group))
fit <- suppressWarnings(fitGrowth(ss))
nlmePlot(fit, form=ss$pcvrForm, df=ss$df)
nlmePlot(fit, form=ss$pcvrForm, df=ss$df, boot=5)
form=ss$pcvrForm; df = ss$df; groups = NULL; timeRange = NULL; boot=3
#* `get needed information from formula`
x <-as.character(form)[3]
y <-as.character(form)[2]
if(grepl("\\|", x) & grepl("\\/",x)){
x3<-trimws(strsplit(x, "[|]|[/]")[[1]])
x<-x3[1]
individual = x3[2]
group = x3[3]
} else if (grepl("\\|", x)){
x2<-trimws(strsplit(x, "[|]")[[1]])
x<-x2[1]
group = x2[2]
individual=NULL
}
#* `filter by groups if groups != NULL`
if(!is.null(groups)){
df <- df[df[[groups]] %in% groups, ]
}
intVar <- paste0(group, individual)
#* `make new data if timerange is not NULL`
if(!is.null(timeRange)){
new_data = do.call(rbind, lapply(unique(df[[intVar]]), function(g){
stats::setNames(data.frame(g, timeRange), c(intVar, x))
}))
} else{
new_data <- df
}
#* `Generate bootstrap predictions`
yvals <- lapply(1:boot, function(i) {try(.predfun(stats::update(fit,
data=.lmePlotResample(fit, df, intVar, y)), new_data),
silent=TRUE )} )
yvals_mat <- do.call(cbind, yvals[which(unlist(lapply(yvals, is.numeric)))])
ncol(yvals_mat)
boot
.lmePlotResample(fit, df, intVar, y)
#' convenience function for pulling CIs
#' @keywords internal
#' @noRd
.lmePlotCIs <- function(y, quantiles = c(0.025, 0.975), prefix="Q_") {
r1 <- t(apply(y,1,quantile, quantiles))
setNames(as.data.frame(r1),paste0(prefix,quantiles))
}
#' Resampling function for bootstrapping CIs
#' @keywords internal
#' @noRd
.lmePlotResample <- function(fitted,data,idvar="group", y="y") {
pp <- stats::predict(fitted,levels=1)
rr <- stats::residuals(fitted)
dd <- data.frame(data, pred=pp, res=rr)
## sample groups with replacement
iv <- levels(data[[idvar]])
bsamp1 <- sample(iv, size=length(iv),replace=TRUE)
res <- do.call(rbind, lapply(bsamp1,
function(x) {
## within groups, sample *residuals* with replacement
ddb <- dd[dd[[idvar]]==x,]
## bootstrapped response = pred + bootstrapped residual
ddb[[y]] <- ddb$pred +
sample(ddb$res,size=nrow(ddb),replace=TRUE)
return(ddb)
}))
return(res)
}
#' Prediction function for bootstrapped values
#' @keywords internal
#' @noRd
.predfun <- function(fm, new_data) {
stats::predict(fm,newdata=new_data,level=0)
}
#* `Generate bootstrap predictions`
yvals <- lapply(1:boot, function(i) {try(.predfun(stats::update(fit,
data=.lmePlotResample(fit, df, intVar, y)), new_data),
silent=TRUE )} )
yvals_mat <- do.call(cbind, yvals[which(unlist(lapply(yvals, is.numeric)))])
while(ncol(yvals_mat) < boot){
new<-try(.predfun(stats::update(fit, data=.lmePlotResample(fit, df, intVar, y)), new_data), silent=TRUE)
if(is.numeric(new)){
yvals_mat <- cbind(yvals_mat, new)
}
}
#* `get CIs from boostrap preds`
predMat<-.lmePlotCIs(yvals_mat, seq(from=99, to=1, by=-2)/100 )
predMat
preds <- cbind(new_data, predMat)
#* `plot CIs`
avg_pal <- viridis::plasma(n=ncol(predMat))
plot <- ggplot2::ggplot(preds, ggplot2::aes(x=.data[[x]]))+
ggplot2::facet_wrap(paste0("~", group)) +
ggplot2::geom_line(data=df, ggplot2::aes(x=.data[[x]], y=.data[[y]],
group = interaction(.data[[individual]],
.data[[group]]) ),
linewidth=0.25, color="gray40")+
lapply(seq(1,49,2)/100,function(i) ggplot2::geom_ribbon(ggplot2::aes(ymin=.data[[paste0("Q_",i)]],
ymax=.data[[paste0("Q_",1-i)]]),
fill=avg_pal[i*100],alpha=0.5))+
ggplot2::labs(x=x, y=y)+
pcv_theme()
plot
?predict.lme
predict(fit, level=0)
length(predict(fit, level=0))
dim(ss$df)
plot(ss$df$time, predict(fit, level=0), type="l")
plot(ss$df$time, ss$df$y, type="l")
gomp_df<-growthSim("gompertz", n=20, t=25,
params = list("A"=c(200,160), "B"=c(13, 11), "C"=c(0.25, 0.25)))
ss<-growthSS(model = "gam", form=y~time|id/group, sigma="power",
df=gomp_df, type = "nlme")
fit <- suppressWarnings(fitGrowth(ss))
plot(ss$df$time, ss$df$y, type="l")
?growthSim
gomp_df<-growthSim("gompertz", n=20, t=25,
params = list("A"=c(200,160), "B"=c(13, 11), "C"=c(0.2, 0.25)))
ss<-growthSS(model = "gam", form=y~time|id/group, sigma="power",
df=gomp_df, type = "nlme")
expect_equal(as.character(ss$formula$model), as.character(y ~ time * group))
fit <- suppressWarnings(fitGrowth(ss))
plot(ss$df$time, ss$df$y, type="l")
ggplot(simdf,aes(time, y, group=interaction(group,id)))+
geom_line(aes(color=group))+labs(title="Gompertz")
plot(ss$df$time, fit$fitted, type="l")
head(fit$fitted)
plot(ss$df$time, fit$fitted$group, type="l")
plot(ss$df$time, fit$fitted[["group"]], type="l")
fit$fitted
class(fit$fitted)
class(fit$fitted[,2])
class(fit$fitted[[2]])
head(fit$fitted[,2])
plot(ss$df$time, fit$fitted[,2], type="l")
plot(ss$df$time, fit$fitted[,1], type="l")
source("~/.active-rstudio-document", echo=TRUE)
lmePlot(fit, form=ss$pcvrForm, df=ss$df)
?lme.formula
ss<-suppressMessages(growthSS(model = "gam", form=y~time|id/group,
df=gomp_df, type = "nlrq"))
ss$formula
fit <- fitGrowth(ss)
fit
class(fit)
nlrqPlot(fit=fit, form=ss$pcvrForm, df = ss$df)
fit
fit$tau
fit$model
fit
form=ss$pcvrForm; df = ss$df; groups=NULL; timeRange=NULL
#fit = fits; form = ss$pcvrForm; groups = NULL; df = ss$df; timeRange = NULL
#* `get needed information from formula`
x <-as.character(form)[3]
y <-as.character(form)[2]
if(grepl("\\|", x) & grepl("\\/",x)){
x3<-trimws(strsplit(x, "[|]|[/]")[[1]])
x<-x3[1]
individual = x3[2]
group = x3[3]
} else if (grepl("\\|", x)){
x2<-trimws(strsplit(x, "[|]")[[1]])
x<-x2[1]
group = x2[2]
individual=NULL
}
#* `filter by groups if groups != NULL`
if(!is.null(groups)){
df <- df[df[[groups]] %in% groups, ]
}
#* `make new data if timerange is not NULL`
if(!is.null(timeRange)){
new_data = do.call(rbind, lapply(unique(df[[group]]), function(g){
stats::setNames(data.frame(g, timeRange), c(group, x))
}))
} else{
new_data <- df
}
#* `standardize fit class`
if(methods::is(fit, "nlrq")){
fit <- list(fit)
names(fit)<-fit[[1]]$m$tau()
}
fit
#* `standardize fit class`
if(methods::is(fit, "rq")){
fit <- list(fit)
names(fit)<-fit[[1]]$m$tau()
}
#* `standardize fit class`
if(methods::is(fit, "rq")){
fit <- list(fit)
names(fit)<-fit[[1]]$m$tau
}
#return(names(fit))
#* `add predictions and record taus`
taus <- as.numeric(unlist(lapply(fit, function(f){f$m$tau()})))
#return(names(fit))
#* `add predictions and record taus`
taus <- as.numeric(unlist(lapply(fit, function(f){f$m$tau})))
preds<-do.call(cbind, lapply(fit, function(f){
tau <- f$m$tau
stats::setNames(data.frame(stats::predict(f, newdata=new_data)), paste0("Q_",tau))
}))
rqPlot<-function(fit, form, df = NULL, groups = NULL, timeRange = NULL){
#fit = fits; form = ss$pcvrForm; groups = NULL; df = ss$df; timeRange = NULL
#* `get needed information from formula`
x <-as.character(form)[3]
y <-as.character(form)[2]
if(grepl("\\|", x) & grepl("\\/",x)){
x3<-trimws(strsplit(x, "[|]|[/]")[[1]])
x<-x3[1]
individual = x3[2]
group = x3[3]
} else if (grepl("\\|", x)){
x2<-trimws(strsplit(x, "[|]")[[1]])
x<-x2[1]
group = x2[2]
individual=NULL
}
#* `filter by groups if groups != NULL`
if(!is.null(groups)){
df <- df[df[[groups]] %in% groups, ]
}
#* `make new data if timerange is not NULL`
if(!is.null(timeRange)){
new_data = do.call(rbind, lapply(unique(df[[group]]), function(g){
stats::setNames(data.frame(g, timeRange), c(group, x))
}))
} else{
new_data <- df
}
#* `standardize fit class`
if(methods::is(fit, "rq")){
fit <- list(fit)
names(fit)<-fit[[1]]$m$tau
}
#return(names(fit))
#* `add predictions and record taus`
taus <- as.numeric(unlist(lapply(fit, function(f){f$m$tau})))
preds<-do.call(cbind, lapply(fit, function(f){
tau <- f$m$tau
stats::setNames(data.frame(stats::predict(f, newdata=new_data)), paste0("Q_",tau))
}))
predCols <-colnames(preds)
keep <- which(!duplicated(preds))
plotdf <- cbind(df[keep,], preds[keep,])
colnames(plotdf) <- c(colnames(df), colnames(preds))
#* `define colors`
virPal_p1<-viridis::plasma(ceiling(length(predCols)/2), direction=1, end=1)
virPal_p2<-viridis::plasma(floor(length(predCols)/2), direction=-1, end=1)
virPal<-c(virPal_p1,virPal_p2)#; scales::show_col(virPal)
#* `layer for individual lines if formula was complete`
if(!is.null(individual)){
individual_lines<-ggplot2::geom_line(data=df, ggplot2::aes(x=.data[[x]], y=.data[[y]],
group = interaction(.data[[individual]],
.data[[group]]) ),
linewidth=0.25, color="gray40")
} else{
individual_lines<-list()
}
#* `plot`
plot<-ggplot(plotdf, ggplot2::aes(group = interaction(.data[[group]])))+
facet_wrap(stats::as.formula(paste0("~",group)))+
individual_lines+
lapply(1:length(predCols), function(i){
ggplot2::geom_line(ggplot2::aes(x=.data[[x]], y=.data[[ predCols[i] ]]), color=virPal[i], linewidth=0.7)
})+
labs(x=x, y = as.character(form)[2])+
pcv_theme()
return(plot)
}
rqPlot(fit=fit, form=ss$pcvrForm, df = ss$df)
source("~/Desktop/stargate/fahlgren_lab/pcvrDocs.R", echo=TRUE)
source("~/Desktop/stargate/fahlgren_lab/pcvrDocs.R", echo=TRUE)
